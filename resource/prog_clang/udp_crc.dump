
udp_crc.o:	file format ELF64-BPF


Disassembly of section prog:

0000000000000000 ping_drop:
; int ping_drop(struct xdp_md *ctx) {
       0:	b7 00 00 00 02 00 00 00	r0 = 2
;     void *data = (void *)(long)ctx->data;    //报文数据开始处
       1:	61 12 00 00 00 00 00 00	r2 = *(u32 *)(r1 + 0)
;     void *end = (void *)(long)ctx->data_end; //报文数据结束点
       2:	61 11 04 00 00 00 00 00	r1 = *(u32 *)(r1 + 4)
;     if (data > end)      //这个检测有点多余，一个合格驱动会保证
       3:	2d 12 26 00 00 00 00 00	if r2 > r1 goto +38 <LBB0_10>
       4:	bf 23 00 00 00 00 00 00	r3 = r2
       5:	07 03 00 00 0e 00 00 00	r3 += 14
       6:	2d 13 23 00 00 00 00 00	if r3 > r1 goto +35 <LBB0_10>
;     if ((void *)(iph + 1) > end) //这里的检测也非常重要，原因同上
       7:	bf 23 00 00 00 00 00 00	r3 = r2
       8:	07 03 00 00 22 00 00 00	r3 += 34
;     if (eh->h_proto != __constant_htons(ETH_P_IP)) //不是IP报文，放过
       9:	2d 13 20 00 00 00 00 00	if r3 > r1 goto +32 <LBB0_10>
      10:	71 23 0d 00 00 00 00 00	r3 = *(u8 *)(r2 + 13)
      11:	67 03 00 00 08 00 00 00	r3 <<= 8
      12:	71 24 0c 00 00 00 00 00	r4 = *(u8 *)(r2 + 12)
      13:	4f 43 00 00 00 00 00 00	r3 |= r4
      14:	57 03 00 00 ff ff 00 00	r3 &= 65535
      15:	55 03 1a 00 08 00 00 00	if r3 != 8 goto +26 <LBB0_10>
;     if (iph->protocol == IPPROTO_UDP) {
      16:	71 23 17 00 00 00 00 00	r3 = *(u8 *)(r2 + 23)
      17:	55 03 18 00 11 00 00 00	if r3 != 17 goto +24 <LBB0_10>
;         if ((void *)(udph + 1) > end) {
      18:	bf 23 00 00 00 00 00 00	r3 = r2
      19:	07 03 00 00 2a 00 00 00	r3 += 42
      20:	2d 13 14 00 00 00 00 00	if r3 > r1 goto +20 <LBB0_9>
      21:	b7 01 00 00 00 00 00 00	r1 = 0
;         int payload_len = udph->len;
      22:	69 24 26 00 00 00 00 00	r4 = *(u16 *)(r2 + 38)
;         for (int i = 0; i < payload_len / 2; i++) {
      23:	77 04 00 00 01 00 00 00	r4 >>= 1
      24:	15 04 0d 00 00 00 00 00	if r4 == 0 goto +13 <LBB0_11>
      25:	b7 01 00 00 00 00 00 00	r1 = 0

00000000000000d0 LBB0_8:
;             sum += ((short *)payload)[i];
      26:	69 35 00 00 00 00 00 00	r5 = *(u16 *)(r3 + 0)
      27:	67 05 00 00 30 00 00 00	r5 <<= 48
      28:	c7 05 00 00 30 00 00 00	r5 s>>= 48
      29:	0f 51 00 00 00 00 00 00	r1 += r5
;             sum = (sum >> 16) + (sum & 0xffff);
      30:	bf 15 00 00 00 00 00 00	r5 = r1
      31:	57 05 00 00 ff ff 00 00	r5 &= 65535
      32:	77 01 00 00 10 00 00 00	r1 >>= 16
      33:	0f 51 00 00 00 00 00 00	r1 += r5
;         for (int i = 0; i < payload_len / 2; i++) {
      34:	07 03 00 00 02 00 00 00	r3 += 2
      35:	07 04 00 00 ff ff ff ff	r4 += -1
      36:	15 04 01 00 00 00 00 00	if r4 == 0 goto +1 <LBB0_11>
      37:	05 00 f4 ff 00 00 00 00	goto -12 <LBB0_8>

0000000000000130 LBB0_11:
;         if (re_checksum != udph->check)
      38:	57 01 00 00 ff ff 00 00	r1 &= 65535
      39:	69 22 28 00 00 00 00 00	r2 = *(u16 *)(r2 + 40)
      40:	1d 12 01 00 00 00 00 00	if r2 == r1 goto +1 <LBB0_10>

0000000000000148 LBB0_9:
      41:	b7 00 00 00 01 00 00 00	r0 = 1

0000000000000150 LBB0_10:
; }
      42:	95 00 00 00 00 00 00 00	exit
