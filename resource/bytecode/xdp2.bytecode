
./xdp2_kern.o:	file format ELF64-BPF


Disassembly of section xdp1:

0000000000000000 xdp_prog1:
; {
       0:	b7 06 00 00 01 00 00 00	r6 = 1
; 	void *data_end = (void *)(long)ctx->data_end;
       1:	61 12 04 00 00 00 00 00	r2 = *(u32 *)(r1 + 4)
; 	void *data = (void *)(long)ctx->data;
       2:	61 17 00 00 00 00 00 00	r7 = *(u32 *)(r1 + 0)
; 	if (data + nh_off > data_end)
       3:	bf 71 00 00 00 00 00 00	r1 = r7
       4:	07 01 00 00 0e 00 00 00	r1 += 14
       5:	2d 21 46 00 00 00 00 00	if r1 > r2 goto +70 <LBB0_20>
; 	h_proto = eth->h_proto;
       6:	71 71 0c 00 00 00 00 00	r1 = *(u8 *)(r7 + 12)
       7:	71 73 0d 00 00 00 00 00	r3 = *(u8 *)(r7 + 13)
       8:	67 03 00 00 08 00 00 00	r3 <<= 8
       9:	4f 13 00 00 00 00 00 00	r3 |= r1
; 	if (h_proto == htons(ETH_P_8021Q) || h_proto == htons(ETH_P_8021AD)) {
      10:	15 03 02 00 88 a8 00 00	if r3 == 43144 goto +2 <LBB0_3>
      11:	b7 01 00 00 0e 00 00 00	r1 = 14
      12:	55 03 05 00 81 00 00 00	if r3 != 129 goto +5 <LBB0_5>

0000000000000068 LBB0_3:
; 		if (data + nh_off > data_end)
      13:	bf 71 00 00 00 00 00 00	r1 = r7
      14:	07 01 00 00 12 00 00 00	r1 += 18
      15:	2d 21 3c 00 00 00 00 00	if r1 > r2 goto +60 <LBB0_20>
      16:	b7 01 00 00 12 00 00 00	r1 = 18
; 		h_proto = vhdr->h_vlan_encapsulated_proto;
      17:	69 73 10 00 00 00 00 00	r3 = *(u16 *)(r7 + 16)

0000000000000090 LBB0_5:
; 	if (h_proto == htons(ETH_P_8021Q) || h_proto == htons(ETH_P_8021AD)) {
      18:	bf 34 00 00 00 00 00 00	r4 = r3
      19:	57 04 00 00 ff ff 00 00	r4 &= 65535
      20:	15 04 01 00 88 a8 00 00	if r4 == 43144 goto +1 <LBB0_7>
      21:	55 04 09 00 81 00 00 00	if r4 != 129 goto +9 <LBB0_9>

00000000000000b0 LBB0_7:
; 		nh_off += sizeof(struct vlan_hdr);
      22:	bf 14 00 00 00 00 00 00	r4 = r1
      23:	07 04 00 00 04 00 00 00	r4 += 4
; 		if (data + nh_off > data_end)
      24:	bf 73 00 00 00 00 00 00	r3 = r7
      25:	0f 43 00 00 00 00 00 00	r3 += r4
      26:	2d 23 31 00 00 00 00 00	if r3 > r2 goto +49 <LBB0_20>
; 		vhdr = data + nh_off;
      27:	bf 73 00 00 00 00 00 00	r3 = r7
      28:	0f 13 00 00 00 00 00 00	r3 += r1
; 		h_proto = vhdr->h_vlan_encapsulated_proto;
      29:	69 33 02 00 00 00 00 00	r3 = *(u16 *)(r3 + 2)
      30:	bf 41 00 00 00 00 00 00	r1 = r4

00000000000000f8 LBB0_9:
; 	if (h_proto == htons(ETH_P_IP))
      31:	57 03 00 00 ff ff 00 00	r3 &= 65535
      32:	15 03 09 00 86 dd 00 00	if r3 == 56710 goto +9 <LBB0_13>
      33:	55 03 10 00 08 00 00 00	if r3 != 8 goto +16 <LBB0_15>
; 	struct iphdr *iph = data + nh_off;
      34:	bf 73 00 00 00 00 00 00	r3 = r7
      35:	0f 13 00 00 00 00 00 00	r3 += r1
      36:	b7 01 00 00 00 00 00 00	r1 = 0
; 	if (iph + 1 > data_end)
      37:	bf 34 00 00 00 00 00 00	r4 = r3
      38:	07 04 00 00 14 00 00 00	r4 += 20
      39:	2d 24 0b 00 00 00 00 00	if r4 > r2 goto +11 <LBB0_16>
; 	return iph->protocol;
      40:	71 31 09 00 00 00 00 00	r1 = *(u8 *)(r3 + 9)
      41:	05 00 09 00 00 00 00 00	goto +9 <LBB0_16>

0000000000000150 LBB0_13:
; 	struct ipv6hdr *ip6h = data + nh_off;
      42:	bf 73 00 00 00 00 00 00	r3 = r7
      43:	0f 13 00 00 00 00 00 00	r3 += r1
      44:	b7 01 00 00 00 00 00 00	r1 = 0
; 	if (ip6h + 1 > data_end)
      45:	bf 34 00 00 00 00 00 00	r4 = r3
      46:	07 04 00 00 28 00 00 00	r4 += 40
      47:	2d 24 03 00 00 00 00 00	if r4 > r2 goto +3 <LBB0_16>
; 	return ip6h->nexthdr;
      48:	71 31 06 00 00 00 00 00	r1 = *(u8 *)(r3 + 6)
      49:	05 00 01 00 00 00 00 00	goto +1 <LBB0_16>

0000000000000190 LBB0_15:
      50:	b7 01 00 00 00 00 00 00	r1 = 0

0000000000000198 LBB0_16:
      51:	63 1a fc ff 00 00 00 00	*(u32 *)(r10 - 4) = r1
      52:	bf a2 00 00 00 00 00 00	r2 = r10
      53:	07 02 00 00 fc ff ff ff	r2 += -4
; 	value = bpf_map_lookup_elem(&rxcnt, &ipproto);
      54:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      56:	85 00 00 00 01 00 00 00	call 1
; 	if (value)
      57:	15 00 03 00 00 00 00 00	if r0 == 0 goto +3 <LBB0_18>
; 		*value += 1;
      58:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
      59:	07 01 00 00 01 00 00 00	r1 += 1
      60:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1

00000000000001e8 LBB0_18:
; 	if (ipproto == IPPROTO_UDP) {
      61:	61 a1 fc ff 00 00 00 00	r1 = *(u32 *)(r10 - 4)
      62:	55 01 0d 00 11 00 00 00	if r1 != 17 goto +13 <LBB0_20>
; 	dst[0] = p[0];
      63:	69 71 00 00 00 00 00 00	r1 = *(u16 *)(r7 + 0)
; 	p[0] = p[3];
      64:	69 72 06 00 00 00 00 00	r2 = *(u16 *)(r7 + 6)
      65:	6b 27 00 00 00 00 00 00	*(u16 *)(r7 + 0) = r2
; 	p[1] = p[4];
      66:	69 72 08 00 00 00 00 00	r2 = *(u16 *)(r7 + 8)
; 	dst[1] = p[1];
      67:	69 73 02 00 00 00 00 00	r3 = *(u16 *)(r7 + 2)
; 	p[4] = dst[1];
      68:	6b 37 08 00 00 00 00 00	*(u16 *)(r7 + 8) = r3
; 	p[1] = p[4];
      69:	6b 27 02 00 00 00 00 00	*(u16 *)(r7 + 2) = r2
; 	p[2] = p[5];
      70:	69 72 0a 00 00 00 00 00	r2 = *(u16 *)(r7 + 10)
; 	dst[2] = p[2];
      71:	69 73 04 00 00 00 00 00	r3 = *(u16 *)(r7 + 4)
; 	p[5] = dst[2];
      72:	6b 37 0a 00 00 00 00 00	*(u16 *)(r7 + 10) = r3
; 	p[3] = dst[0];
      73:	6b 17 06 00 00 00 00 00	*(u16 *)(r7 + 6) = r1
; 	p[2] = p[5];
      74:	6b 27 04 00 00 00 00 00	*(u16 *)(r7 + 4) = r2
      75:	b7 06 00 00 03 00 00 00	r6 = 3

0000000000000260 LBB0_20:
; }
      76:	bf 60 00 00 00 00 00 00	r0 = r6
      77:	95 00 00 00 00 00 00 00	exit
